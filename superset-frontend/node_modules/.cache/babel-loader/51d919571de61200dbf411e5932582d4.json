{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _JSON$stringify from \"@babel/runtime-corejs3/core-js-stable/json/stringify\";import _Array$from from \"@babel/runtime-corejs3/core-js-stable/array/from\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";var _jsxFileName = \"/Users/frankhe/projects/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { ParentSize } from '@vx/responsive';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport getLeafComponentIdFromPath from 'src/dashboard/util/getLeafComponentIdFromPath';\nimport { DASHBOARD_GRID_ID, DASHBOARD_ROOT_DEPTH } from 'src/dashboard/util/constants';\nimport { getRootLevelTabIndex, getRootLevelTabsComponent } from './utils';\nimport { getChartIdsInFilterScope } from '../../util/activeDashboardFilters';\nimport findTabIndexByComponentId from '../../util/findTabIndexByComponentId';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { setInScopeStatusOfFilters } from '../../actions/nativeFilters';import { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst DashboardContainer = ({ topLevelTabs }) => {var _useSelector, _context;\n  const dashboardLayout = useSelector((state) => state.dashboardLayout.present);\n  const nativeFilters = (_useSelector = useSelector((state) => {var _state$nativeFilters;return (_state$nativeFilters = state.nativeFilters) == null ? void 0 : _state$nativeFilters.filters;})) != null ? _useSelector :\n  {};\n  const directPathToChild = useSelector((state) => state.dashboardState.directPathToChild);\n  const [tabIndex, setTabIndex] = useState(getRootLevelTabIndex(dashboardLayout, directPathToChild));\n  const dispatch = useDispatch();\n  useEffect(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild });\n\n    if (nextTabIndex > -1) {\n      setTabIndex(nextTabIndex);\n    }\n  }, [getLeafComponentIdFromPath(directPathToChild)]);\n  // recalculate charts and tabs in scopes of native filters only when a scope or dashboard layout changes\n  const filterScopes = _mapInstanceProperty(_context = _Object$values(nativeFilters)).call(_context, (filter) => ({\n    id: filter.id,\n    scope: filter.scope }));\n\n  useEffect(() => {\n    if (!isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) ||\n    filterScopes.length === 0) {\n      return;\n    }\n    const scopes = _mapInstanceProperty(filterScopes).call(filterScopes, (filterScope) => {\n      const { scope } = filterScope;\n      const chartsInScope = getChartIdsInFilterScope({\n        filterScope: {\n          scope: scope.rootPath,\n          // @ts-ignore\n          immune: scope.excluded } });\n\n\n      const tabsInScope = findTabsWithChartsInScope(dashboardLayout, chartsInScope);\n      return {\n        filterId: filterScope.id,\n        tabsInScope: _Array$from(tabsInScope),\n        chartsInScope };\n\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [_JSON$stringify(filterScopes), dashboardLayout, dispatch]);\n  const childIds = topLevelTabs ?\n  topLevelTabs.children :\n  [DASHBOARD_GRID_ID];\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n  return ___EmotionJSX(\"div\", { className: \"grid-container\", \"data-test\": \"grid-container\", __self: this, __source: { fileName: _jsxFileName, lineNumber: 83, columnNumber: 13 } },\n  ___EmotionJSX(ParentSize, { __self: this, __source: { fileName: _jsxFileName, lineNumber: 84, columnNumber: 7 } },\n  ({ width }) =>\n  /*\n    We use a TabContainer irrespective of whether top-level tabs exist to maintain\n    a consistent React component tree. This avoids expensive mounts/unmounts of\n    the entire dashboard upon adding/removing top-level tabs, which would otherwise\n    happen because of React's diffing algorithm\n  */\n  ___EmotionJSX(Tabs, { id: DASHBOARD_GRID_ID, activeKey: activeKey, renderTabBar: () => ___EmotionJSX(React.Fragment, null), fullWidth: false, animated: false, allowOverflow: true, __self: this, __source: { fileName: _jsxFileName, lineNumber: 92, columnNumber: 9 } },\n  _mapInstanceProperty(childIds).call(childIds, (id, index) =>\n  // Matching the key of the first TabPane irrespective of topLevelTabs\n  // lets us keep the same React component tree when !!topLevelTabs changes.\n  // This avoids expensive mounts/unmounts of the entire dashboard.\n  ___EmotionJSX(Tabs.TabPane, { key: index === 0 ? DASHBOARD_GRID_ID : index.toString(), __self: this, __source: { fileName: _jsxFileName, lineNumber: 97, columnNumber: 13 } },\n  ___EmotionJSX(DashboardGrid, { gridComponent: dashboardLayout[id]\n    // see isValidChild for why tabs do not increment the depth of their children\n    , depth: DASHBOARD_ROOT_DEPTH + 1 // (topLevelTabs ? 0 : 1)}\n    , width: width, isComponentVisible: index === tabIndex, __self: this, __source: { fileName: _jsxFileName, lineNumber: 98, columnNumber: 17 } }))))));\n\n\n\n\n};__signature__(DashboardContainer, \"useSelector{dashboardLayout}\\nuseSelector{}\\nuseSelector{directPathToChild}\\nuseState{[tabIndex, setTabIndex](getRootLevelTabIndex(dashboardLayout, directPathToChild))}\\nuseDispatch{dispatch}\\nuseEffect{}\\nuseEffect{}\", () => [useSelector, useSelector, useSelector, useDispatch]);const _default =\nDashboardContainer;export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(DashboardContainer, \"DashboardContainer\", \"/Users/frankhe/projects/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");reactHotLoader.register(_default, \"default\", \"/Users/frankhe/projects/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/Users/frankhe/projects/superset/superset-frontend/src/dashboard/components/DashboardBuilder/DashboardContainer.tsx"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n// ParentSize uses resize observer so the dashboard will update size\n// when its container size changes, due to e.g., builder side panel opening\nimport React, { FC, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { ParentSize } from '@vx/responsive';\nimport Tabs from 'src/components/Tabs';\nimport DashboardGrid from 'src/dashboard/containers/DashboardGrid';\nimport getLeafComponentIdFromPath from 'src/dashboard/util/getLeafComponentIdFromPath';\nimport { DashboardLayout, LayoutItem, RootState } from 'src/dashboard/types';\nimport {\n  DASHBOARD_GRID_ID,\n  DASHBOARD_ROOT_DEPTH,\n} from 'src/dashboard/util/constants';\nimport { getRootLevelTabIndex, getRootLevelTabsComponent } from './utils';\nimport { Filters } from '../../reducers/types';\nimport { getChartIdsInFilterScope } from '../../util/activeDashboardFilters';\nimport findTabIndexByComponentId from '../../util/findTabIndexByComponentId';\nimport { findTabsWithChartsInScope } from '../nativeFilters/utils';\nimport { setInScopeStatusOfFilters } from '../../actions/nativeFilters';\n\ntype DashboardContainerProps = {\n  topLevelTabs?: LayoutItem;\n};\n\nconst DashboardContainer: FC<DashboardContainerProps> = ({ topLevelTabs }) => {\n  const dashboardLayout = useSelector<RootState, DashboardLayout>(\n    state => state.dashboardLayout.present,\n  );\n  const nativeFilters =\n    useSelector<RootState, Filters>(state => state.nativeFilters?.filters) ??\n    {};\n  const directPathToChild = useSelector<RootState, string[]>(\n    state => state.dashboardState.directPathToChild,\n  );\n  const [tabIndex, setTabIndex] = useState(\n    getRootLevelTabIndex(dashboardLayout, directPathToChild),\n  );\n\n  const dispatch = useDispatch();\n\n  useEffect(() => {\n    const nextTabIndex = findTabIndexByComponentId({\n      currentComponent: getRootLevelTabsComponent(dashboardLayout),\n      directPathToChild,\n    });\n    if (nextTabIndex > -1) {\n      setTabIndex(nextTabIndex);\n    }\n  }, [getLeafComponentIdFromPath(directPathToChild)]);\n\n  // recalculate charts and tabs in scopes of native filters only when a scope or dashboard layout changes\n  const filterScopes = Object.values(nativeFilters).map(filter => ({\n    id: filter.id,\n    scope: filter.scope,\n  }));\n  useEffect(() => {\n    if (\n      !isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS) ||\n      filterScopes.length === 0\n    ) {\n      return;\n    }\n    const scopes = filterScopes.map(filterScope => {\n      const { scope } = filterScope;\n      const chartsInScope: number[] = getChartIdsInFilterScope({\n        filterScope: {\n          scope: scope.rootPath,\n          // @ts-ignore\n          immune: scope.excluded,\n        },\n      });\n      const tabsInScope = findTabsWithChartsInScope(\n        dashboardLayout,\n        chartsInScope,\n      );\n      return {\n        filterId: filterScope.id,\n        tabsInScope: Array.from(tabsInScope),\n        chartsInScope,\n      };\n    });\n    dispatch(setInScopeStatusOfFilters(scopes));\n  }, [JSON.stringify(filterScopes), dashboardLayout, dispatch]);\n\n  const childIds: string[] = topLevelTabs\n    ? topLevelTabs.children\n    : [DASHBOARD_GRID_ID];\n\n  const min = Math.min(tabIndex, childIds.length - 1);\n  const activeKey = min === 0 ? DASHBOARD_GRID_ID : min.toString();\n\n  return (\n    <div className=\"grid-container\" data-test=\"grid-container\">\n      <ParentSize>\n        {({ width }) => (\n          /*\n            We use a TabContainer irrespective of whether top-level tabs exist to maintain\n            a consistent React component tree. This avoids expensive mounts/unmounts of\n            the entire dashboard upon adding/removing top-level tabs, which would otherwise\n            happen because of React's diffing algorithm\n          */\n          <Tabs\n            id={DASHBOARD_GRID_ID}\n            activeKey={activeKey}\n            renderTabBar={() => <></>}\n            fullWidth={false}\n            animated={false}\n            allowOverflow\n          >\n            {childIds.map((id, index) => (\n              // Matching the key of the first TabPane irrespective of topLevelTabs\n              // lets us keep the same React component tree when !!topLevelTabs changes.\n              // This avoids expensive mounts/unmounts of the entire dashboard.\n              <Tabs.TabPane\n                key={index === 0 ? DASHBOARD_GRID_ID : index.toString()}\n              >\n                <DashboardGrid\n                  gridComponent={dashboardLayout[id]}\n                  // see isValidChild for why tabs do not increment the depth of their children\n                  depth={DASHBOARD_ROOT_DEPTH + 1} // (topLevelTabs ? 0 : 1)}\n                  width={width}\n                  isComponentVisible={index === tabIndex}\n                />\n              </Tabs.TabPane>\n            ))}\n          </Tabs>\n        )}\n      </ParentSize>\n    </div>\n  );\n};\n\nexport default DashboardContainer;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}